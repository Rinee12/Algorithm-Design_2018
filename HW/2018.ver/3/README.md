# BFS, DFS, Kruskal, Prim 알고리즘 


## 개요

이번 과제는 수업 시간에 배워본 BFS, DFS, Kruskal, Prim 알고리즘을 구현해보고 테스트 해보는 과제이다. 

BFS 와 DFS 알고리즘은 그래프 알고리즘으로써 그래프를 탐색하는 두 가지 방법이다. 

BFS(breadth first search)는 너비 우선 탐색으로써 탐색을 시작할 정점 i를 방문하고 i에 

인접한 다른 정점 중 아직 방문하지 않는 정점을 큐에 저장하여 큐에서 정점을 삭제해 그 정점을 탐색 시작 점 i로 재설정해 

위에 과정을 반복하여 큐가 공백이 되면 연산이 종료되는 알고리즘이다. 

이를 시행하면 그림 1과 같은 순서로 정점이 출력된다.

DFS(depth first search)는 깊이 우선 탐색으로써 탐색을 시작할 정점 i를 방문하고 

i에 인접한 정점 중 아직 방문하지 않은 정점을 스택에 저장하여 이 스택에서 정점을 삭제해 이 삭제한 정점을 

다음 방문할 i로 설정해 위를 반복한 후 스택이 공백이 되면 연산이 종료되는 알고리즘이다. 

즉 이 두 알고리즘은 비슷한 구조를 가지고 있으나 저장하는 방식이 큐와 스택으로 달라 pop하는 순서가 달라져 다른 결과를 가져오게 된다.


## 상세 설계내용
### 1) BFS & DFS

BFS와 DFS는 노드의 개수와 간선을 입력 받아 가중치 행렬 W를 만들어 BFS와 DFS가 실행되도록 만들었다. 

만들 때 BFS와 DFS는 각각 queue와 stack 헤더를 사용하였고 함수와 메인함수에서 그래프에 접근할 수 있도록 

전역변수로 graph배열을 선언하였다. 그리고 노드의 방문 여부를 확인해주기 위해 전역변수로 visit 배열을 선언하였다. 

그리고 간선을 출력하기 위하여 struct node를 선언하여 queue나 stack에 push 할 때 연결 노드까지 

push 하여 어떤 간선을 이용하는지 출력하였다.

### 2) Kruskal & Prim

Kruskal 과 Prim 집합을 저장할 struct와 edge 정보를 저장할 struct 그리고 vertice 정보를 저장할 struct 이렇게 3개의 struct를 선언하였다. 

그리고 edge 배열을 선언하여 거리를 저장하도록 하였다. 

Kruskal 함수의 처음에 간선의 가중치를 정렬해야 하므로 quick sort 함수를 사용하였다. (이는 다른 sorting을 사용하여도 무관하다). 

그리고 사이클 방지 검사를 위해 find 함수와 merge 함수를 선언하였다. 

Find 함수는 해당되는 정점이 포함된 집합을 찾는 함수이고 merge 함수는 정점 v1, v2가 속한 집합을 합치는 함수이다. 

Prim 함수의 경우 간선을 저장하기 위해 queue를 사용하였고 이에 edge struct를 넣을 수 있도록 설정하였다. 

그리고 간선의 수가 정점보다 하나 작을 때까지 가중치가 가장 작은 간선을 큐에 저장하고 이를 비교하여 저장하도록 하였다

사이클 방지 함수에 대해 좀 더 자세히 설명하자면 여기서 사이클 방지 함수로 disjoint set(of union find) 알고리즘을 사용하였다. 

Merge 함수를 이용하면 v1과 v2는 같은 집합에 들어가게 되며 v1과 v2가 같은 집합일 때만 find(v1)과 find(v2)가 같은 값을 가지게 된다.  


## 분석 및 결론

이번 과제를 통해 BFS, DFS, kruskal, prim 등 그래프 알고리즘들을 코딩 해보았다. 

이를 통해 각 알고리즘이 어떤 순서로 코딩되는지 알 수 있었고 이때 사용한 stack, queue, disjoint set 등을 자세히 알 수 있었다. 

그리고 이를 수업시간에 한 노드가 적은 그래프뿐만 아니라 노드가 20개 인 큰 그래프에서 도 사용해보아 좀 더 자세히 진행 과정을 알 수 있었다. 


in 2018 May

